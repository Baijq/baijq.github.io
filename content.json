{"meta":{"title":"BiuBiu","subtitle":"记录、学习、生活","description":"诗酒趁年华","author":"biubiu","url":"https://baijq.github.io","root":"/"},"pages":[{"title":"关于我","date":"2021-08-09T13:08:08.000Z","updated":"2021-08-09T14:58:22.291Z","comments":true,"path":"about/index.html","permalink":"https://baijq.github.io/about/index.html","excerpt":"","text":"BiuBiu:（让坚持成为品质，让优秀成为习惯）一个初入江湖的95后搬砖小伙。出生于甘肃某个宁静的的小山村。喜欢有趣的事情，有趣的人。喜欢优美的文字。喜欢简单，恬静。文笔不好，希望借博客锻炼一哈！ 本站分享内容 IT相关技术分享，分享是一种博爱的心境，学会分享，就学会了生活。 工具使用心得分享 生活趣事 偶尔写写文章，练练手 联系方式E-Mail：&#x62;&#97;&#105;&#x6a;&#x71;&#x6d;&#97;&#105;&#108;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;"},{"title":"分类","date":"2021-08-09T13:08:08.000Z","updated":"2021-08-09T13:17:08.405Z","comments":true,"path":"categories/index.html","permalink":"https://baijq.github.io/categories/index.html","excerpt":"","text":"title: 分类测试文章标题categories: 分类名"},{"title":"tags","date":"2021-08-09T13:16:36.000Z","updated":"2021-08-09T13:16:58.052Z","comments":true,"path":"tags/index.html","permalink":"https://baijq.github.io/tags/index.html","excerpt":"","text":"title: 标签测试文章标题tags: 标签1 标签2…"}],"posts":[{"title":"Java基础知识回顾","slug":"我的第一篇博客","date":"2021-08-08T12:05:37.000Z","updated":"2021-08-09T15:29:54.532Z","comments":true,"path":"2021/08/08/我的第一篇博客/","link":"","permalink":"https://baijq.github.io/2021/08/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。 后来 Sun 公司被 Oracle （甲骨文）公司收购.","text":"Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。 后来 Sun 公司被 Oracle （甲骨文）公司收购. Java核心基础一、基础知识1.1 Java8 lambda表达式和Stream1.1.1 Stream基础Stream是Java 8提出了的一种新的对集合对象功能的增强。它集合Lambda表达式，对集合提供了一些非常便利，高效的操作，使得代码具有非常高的可读性，优雅性！！举个例子来说，它就像一个流水线操作，对输入流水线的东西（水果）进行一系列加工处理，最后获取到我们需要的某种特殊的水果（没有洗过的苹果）。 Stream提供了对集合的便捷化处理方式 声明式编程的思想 代码更加优雅，简洁，不信你看→_→ Stream的创建 1234567891011121314151617//通过List集合创建List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);//list.stream()Stream&lt;String&gt; stream = list.stream();//直接通过指定的元素创建Stream&lt;String&gt; stream = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);//通过数组ArrayString[] arrays = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;Stream&lt;String&gt; stream = Stream.of(arrays);//和上面区别不大Stream&lt;String&gt; stream1 = Arrays.stream(arrays);IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println); Stream的流水线操作 Stream Operation Goal Input filter filter 方法用于通过设置的条件过滤出元素。 条件（返回布尔值）Predicate map map 方法用于映射每个元素到对应的结果 可以是一个功能 Function limit limit 方法用于获取指定数量的流 int值 sorted sorted 方法用于对流进行排序 Comparator distinct 去除重复 – parallel parallelStream 是流并行处理程序的代替方法 – - **filter**统计空字符串的个数 123List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量int count = strings.stream().filter(string -&gt; string.isEmpty()).count() - **map** 使用 map 输出了元素对应的平方数 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);// 获取对应的平方数List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList()); - **limit**使用 limit 方法打印出 10 条数据 12Random random = new Random();random.ints().limit(10).forEach(System.out::println); - **sorted**使用 sorted 方法对输出的 10 个随机数进行排序 12Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println); - **distinct**使用 distinct 对元素进行去重 12List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().distinct().forEach(System.out::println); - **parallel** 使用 parallelStream 来输出空字符串的数量 123List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量int count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count(); 终端操作 Stream Operation Goal Input Or Output forEach 遍历元素 其他操作 count 统计元素个数 – collect 聚合操作 – - **forEach**遍历打印 1Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).forEach(System.out::println); - **count**统计&#39;a&#39;的数量 1long count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;).filter(x -&gt; &quot;a&quot;.equals(x)).count();//2 - **collect**聚合 123456789// 1. 聚合转成ListList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));// 2. 聚合转成SetSet set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. 聚合转成StringString str = stream.collect(Collectors.joining()).toString();// 4. ···其他 1.1.2 Optional1234567891011121314151617181920212223242526272829/** * 1. Optional.of(obj) * 为非null的对象创建一个Optional * obj不能把为null，否则NPE *///Optional[Demo]Optional&lt;String&gt; opt1s = Optional.of(&quot;Demo&quot;);//NPEOptional&lt;Object&gt; opt1o = Optional.of(null);/** * 2. Optional.ofNullable(obj) * 参数obj可以为null *///Optional[Demo]Optional&lt;String&gt; opt2s = Optional.ofNullable(&quot;Demo&quot;);//Optional.emptyOptional&lt;Object&gt; opt2o = Optional.ofNullable(null);/** * 3. opt.isPresent() * opt存在，返回true * 否则，返回false *///trueSystem.out.println(opt2s.isPresent());//falseSystem.out.println(opt2o.isPresent()); 1.1.3 去重应用12//list集合中根据userName去重List&lt;User&gt; lists = lists.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(User::getUsrName))), ArrayList::new)); 1.1.4 排序应用1234List&lt;PromotionForHomeDto&gt; list = promotionBasicDao.list(new WherePrams().orderBy(&quot;create_time desc&quot;));list = list.stream().sorted(Comparator.comparing(PromotionForHomeDto::getCreateTime)) .collect(Collectors.toList()); 1.1.5 综合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class StreamTest &#123; public static void main(String[] args) &#123; //学生 List&lt;Student&gt; students = initStudentList(); System.out.println(&quot;源数据：&quot; + JSONObject.toJSONString(students)); //筛选出武汉大学的学生 List&lt;Student&gt; whuStudents = students.stream() .filter(student -&gt; &quot;华中科技大学&quot;.equals(student.getSchool())) .collect(Collectors.toList()); System.out.println(&quot;filter：&quot; + JSONObject.toJSONString(whuStudents)); //limit List&lt;Student&gt; civilStudents = students.stream() .filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor())) .limit(2) .collect(Collectors.toList()); System.out.println(&quot;limit：&quot; + JSONObject.toJSONString(civilStudents)); //skip List&lt;Student&gt; skitCivilStudents = students.stream() .filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor())) .skip(2) .collect(Collectors.toList()); System.out.println(&quot;skip：&quot; + JSONObject.toJSONString(skitCivilStudents)); //sort List&lt;Student&gt; sortedCivilStudents = students.stream() .filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor())) .sorted(Comparator.comparingInt(Student::getAge)) .limit(2) .collect(Collectors.toList()); System.out.println(&quot;sort：&quot; + JSONObject.toJSONString(sortedCivilStudents)); //map List&lt;String&gt; names = students.stream() .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor())) .map(Student::getName) .collect(Collectors.toList()); System.out.println(&quot;map：&quot; + JSONObject.toJSONString(names)); //mapToInt int totalAge = students.stream() .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor())) .mapToInt(Student::getAge) .sum(); System.out.println(totalAge); &#125; private static List&lt;Student&gt; initStudentList() &#123; List&lt;Student&gt; students = new ArrayList&lt;Student&gt;() &#123; &#123; add(new Student(20160001, &quot;孔明&quot;, 20, 1, &quot;土木工程&quot;, &quot;武汉大学&quot;)); add(new Student(20160002, &quot;伯约&quot;, 21, 2, &quot;信息安全&quot;, &quot;武汉大学&quot;)); add(new Student(20160003, &quot;玄德&quot;, 22, 3, &quot;经济管理&quot;, &quot;武汉大学&quot;)); add(new Student(20160004, &quot;云长&quot;, 21, 2, &quot;信息安全&quot;, &quot;武汉大学&quot;)); add(new Student(20161001, &quot;翼德&quot;, 21, 2, &quot;机械与自动化&quot;, &quot;华中科技大学&quot;)); add(new Student(20161002, &quot;元直&quot;, 23, 4, &quot;土木工程&quot;, &quot;华中科技大学&quot;)); add(new Student(20161003, &quot;奉孝&quot;, 23, 4, &quot;计算机科学&quot;, &quot;华中科技大学&quot;)); add(new Student(20162001, &quot;仲谋&quot;, 22, 3, &quot;土木工程&quot;, &quot;浙江大学&quot;)); add(new Student(20162002, &quot;鲁肃&quot;, 23, 4, &quot;计算机科学&quot;, &quot;浙江大学&quot;)); add(new Student(20163001, &quot;丁奉&quot;, 24, 5, &quot;土木工程&quot;, &quot;南京大学&quot;)); &#125; &#125;; return students; &#125;&#125; 1.2 Java创建对象 方式一 new 1Student s = new Student(); 方式二 反射 1234Student s = (Student)Student.forName(&quot;com.demo.Student&quot;).newInstance();//或者Student s = Student.class.newInstance();//##事实上Class的newInstance方法内部调用的也是Constructor的newInstance方法。 方式三 反射，利用构造器 1public class Student &#123; private Integer id; public Student(Integer id) &#123; this.id = id; &#125; public static void main(String[] args) throws Exception &#123; // 首先得到要实例化类的构造器（有参） Constructor&lt;Student&gt; constructor = Student.class.getConstructor(Integer.class); Student s = constructor.newInstance(12); &#125;&#125; 方式四 Clone （不会调用任何构造函数） 123456789101112131415public class Student implements Cloneable &#123; private Integer id; public Student(Integer id) &#123; this.id = id; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; public static void main(String[] args) throws Exception &#123; Constructor&lt;Student&gt; constructor = Student.class.getConstructor(Integer.class); Student stu3 = constructor.newInstance(13); Student stu4 = (Student) stu3.clone(); &#125;&#125; 方式五 （(反)序列化机制）（不会调用构造函数） 12345678910111213141516171819202122public class Student implements Serializable &#123; private int id; public Student(Integer id) &#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;]&quot;; &#125; public static void main(String[] args) throws Exception &#123; Constructor&lt;Student&gt; constructor = Student.class.getConstructor(Integer.class); Student stu3 = constructor.newInstance(123); // 写对象 ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;student.bin&quot;)); output.writeObject(stu3); output.close(); // 读对象 ObjectInputStream input = new ObjectInputStream(new FileInputStream( &quot;student.bin&quot;)); Student stu5 = (Student) input.readObject(); System.out.println(stu5); &#125;&#125; 1.3 字符串String相关 String,StringBuffer,StringBuilder，都是final修饰的类，都不能被继承 Stringprivate final char value[]; 所以每次用String都需要在堆上创建对象 StringBuffer, StringBuilderchar[] value; 效率： StringBuilder &gt; StringBuffer &gt; String 线城安全性：StringBuffer线城安全 二、算法一、深度优先搜索（Depth-First Search，DFS）当我们深入到叶结点时回溯，这就被称为 DFS 算法。 让我们分解一下： 从根结点（1）开始。输出 进入左结点（2）。输出 然后进入左孩子（3）。输出 回溯，并进入右孩子（4）。输出 回溯到根结点，然后进入其右孩子（5）。输出 进入左孩子（6）。输出 回溯，并进入右孩子（7）。输出 完成 1. 前序遍历 输出结果为： 1–2–3–4–5–6–7 这和我们在上述示例中的作法基本类似。 输出节点的值 进入其左结点并输出。当且仅当它拥有左结点。 进入右结点并输出之。当且仅当它拥有右结点 123456789101112/** 深度优先搜索（Depth-First Search，DFS）--前序遍历 **/public static void preOrder(BinaryTree node) &#123; if (null != node) &#123; System.out.println(node.data); if (null != node.left) &#123; node.left.preOrder(node.left); &#125; if (null != node.right) &#123; node.right.preOrder(node.right); &#125; &#125;&#125; 2. 中序遍历 输出结果3–2–4–1–6–5–7 左结点优先，之后是中间，最后是右结点。 进入左结点并输出之。当且仅当它有左结点。 输出根结点的值。 进入结节点并输出之。当且仅当它有结节点。 123456789101112/** 深度优先搜索（Depth-First Search，DFS）--中序遍历 **/public static void inOrder(BinaryTree node) &#123; if (null != node) &#123; if (null != node.left) &#123; node.left.inOrder(node.left); &#125; System.out.println(node.data); if (null != node.right) &#123; node.right.inOrder(node.right); &#125; &#125;&#125; 2. 后序遍历 输出结果3–4–2–6–7–5–1 左结点优先，之后是右结点，根结点的最后。 进入左结点输出， 进入右结点输出 输出根结点 123456789101112/** 深度优先搜索（Depth-First Search，DFS）--后序遍历 **/public static void postOrder(BinaryTree node) &#123; if (null != node) &#123; if (null != node.left) &#123; node.left.postOrder(node.left); &#125; if (node.right != null) &#123; node.right.postOrder(node.right); &#125; System.out.println(node.data); &#125;&#125; 参考博客：https://blog.csdn.net/dandandeshangni/article/details/79972501 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.list2tree.tree;import lombok.Data;@Datapublic class BinaryTree &#123; /** 树的内容 **/ protected String data; protected BinaryTree left; protected BinaryTree right; public BinaryTree() &#123; &#125; public BinaryTree(String data, BinaryTree left, BinaryTree right) &#123; this.data = data; this.left = left; this.right = right; &#125; public BinaryTree(String data) &#123; this(data, null, null); &#125; /** 插入节点 ，如果当前的节点没有左节点，我们就创建一个新节点，然后将其设置为当前节点的左节点。 **/ public static void insertLeft(BinaryTree node, String value) &#123; if (null != node) &#123; if (null == node.left) &#123; node.setLeft(new BinaryTree(value)); &#125; else &#123; BinaryTree newNode = new BinaryTree(value); newNode.left = node.left; node.left = newNode; &#125; &#125; &#125; /** 插入节点 ，如果当前的节点没有右节点，我们就创建一个新节点，然后将其设置为当前节点的右节点。 **/ public static void insertRight(BinaryTree node, String value) &#123; if (null != node) &#123; if (node.right == null) &#123; node.setRight(new BinaryTree(value)); &#125; else &#123; BinaryTree newNode = new BinaryTree(value); newNode.right = node.right; node.right = newNode; &#125; &#125; &#125; /** 深度优先搜索（Depth-First Search，DFS）--前序遍历 **/ public static void preOrder(BinaryTree node) &#123; if (null != node) &#123; System.out.println(node.data); if (null != node.left) &#123; node.left.preOrder(node.left); &#125; if (null != node.right) &#123; node.right.preOrder(node.right); &#125; &#125; &#125; /** 深度优先搜索（Depth-First Search，DFS）--中序遍历 **/ public static void inOrder(BinaryTree node) &#123; if (null != node) &#123; if (null != node.left) &#123; node.left.inOrder(node.left); &#125; System.out.println(node.data); if (null != node.right) &#123; node.right.inOrder(node.right); &#125; &#125; &#125; /** 深度优先搜索（Depth-First Search，DFS）--后序遍历 **/ public static void postOrder(BinaryTree node) &#123; if (null != node) &#123; if (null != node.left) &#123; node.left.postOrder(node.left); &#125; if (node.right != null) &#123; node.right.postOrder(node.right); &#125; System.out.println(node.data); &#125; &#125;&#125; 其他1 读取配置文件properties123456789101112131415static &#123; Properties prop = new Properties(); try &#123; prop.load(JDBCUtil.class.getResourceAsStream(&quot;conninfo.properties&quot;)) String driver = prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); //注册驱动 Class.forName(driver); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125;&#125; 2 Java对象根据某属性去重12345678910List&lt;MenuInfo&gt; menuInfos;//定义一个空map，用来装去重后的数据Map&lt;String, MenuInfo&gt; map = new HashMap&lt;&gt;();for(MenuInfo menu : menuInfos) &#123; if(!map.containsKey(menu.getId())) &#123; map.put(menu.getId(), menu); &#125;&#125; 3 发送Http请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLConnection;import javax.net.ssl.HttpsURLConnection;import org.springframework.web.bind.annotation.RequestMethod;import com.springtour.app.util.StringUtil;import oracle.net.aso.i;/** * HTTP传输工具类 * @author gusaishuai * @since 2013-10-10 * &lt;p&gt;Copyright © Spring Airlines;Spring Travel.All rights reserved. */public class HttpUtil &#123; /** * JSON通过HTTP传输 */ public static String urlJSONRequest(String json, String address) &#123; try &#123; URL url = new URL(address); if (address.toLowerCase().contains(&quot;https&quot;)) &#123; HTTPSTrustManager.allowAllSSL(); &#125; HttpURLConnection con = (HttpURLConnection) url.openConnection(); con.setRequestMethod(RequestMethod.POST.name()); con.setUseCaches(false); con.setDoInput(true); con.setDoOutput(true); //5000是connectTimeout，30000是readTimeout con.setConnectTimeout(5000); con.setReadTimeout(30000); con.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); con.connect(); BufferedWriter out = new BufferedWriter( new OutputStreamWriter(con.getOutputStream(), &quot;UTF-8&quot;)); out.write(json); out.flush(); out.close(); BufferedReader in = new BufferedReader( new InputStreamReader(con.getInputStream(), &quot;UTF-8&quot;)); StringBuilder sb = new StringBuilder(); String line = null; while (!StringUtil.isEmpty(line = in.readLine())) &#123; sb.append(line); &#125; in.close(); return sb.toString(); &#125; catch (Exception e) &#123; LogUtil.logError(&quot;HTTP-POST请求传输JSON&quot;, &quot;&quot;, e, &quot;JSON：&quot; + json + &quot;，ADDRESS：&quot; + address); return &quot;&quot;; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-08-08T12:02:13.236Z","updated":"2021-08-08T14:17:00.974Z","comments":true,"path":"2021/08/08/hello-world/","link":"","permalink":"https://baijq.github.io/2021/08/08/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}